#!/bin/bash

#H::
#H:: Helps dealing with entando apps
#H::
#H:: Syntax:
#H::  - ent app {command} ...
#H::
#H:: Commands:

[[ "$1" == "--help" && "$2" == "--short" ]] && {
  echo -e "Helps managing an EntandoApp" && exit 0
}

[ "$1" = "--cmplt" ] && {
  . s/essentials.sh
  print_ent_module_sub-commands "${BASH_SOURCE[0]}"
  exit 0
}

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
cd "$DIR/../.." || {
  echo "Internal error: unable to find the script source dir" 1>&2
  exit
}

. s/_base.sh

RUN() {
  HH="$(parse_help_option "$@")"

  show_help_option "$HH" ":main"
  args_or_ask ${HH:+"$HH"} -a -n -- "CMD" '1///%sp command' "$@"
  args_or_ask ${HH:+"$HH"} -n -p NAMESPACE "--namespace/ext_ic_id//%sp the kubernetes namespace" "$@"

  show_help_option "$HH" "$CMD"

  case "$CMD" in
  "use") #H: selects the app context that ent should use
    args_or_ask ${HH:+"$HH"} -n -F "NO_AUTO_LOGIN" "--no-auto-login///Disable auto-login" "$@"
    args_or_ask ${HH:+"$HH"} -n -F "AUTO_YES" "--yes///Assumes yes for all yes-no questions" "$@"
    args_or_ask ${HH:+"$HH"} -n -F "AUTO_NO" "--no///Assumes no for all yes-no questions" "$@"
    args_or_ask ${HH:+"$HH"} -n -F "USE_NO_APPCTX" "--none///Assumes the global application context" "$@"
    args_or_ask ${HH:+"$HH"} -F USE_CURRENT_DIR "-l///Uses the local dir as based app dir" "$@"
    [ -n "$HH" ] && exit 0
    shift
    APP_LOGIN_URL=""
    APP_LOGIN_TOKEN=""
    DESIGNATED_VM=""
    use_app_ctx "$@"
    ! $USE_NO_APPCTX && {
      #app_ctx_auto_login
      app_ctx_auto_select_kube_context
      app_ctx_auto_attach
    }
    ;;
  "new") #H: created a new app context
    shift
    new_app_ctx "$@"
    ;;
  "set") #H: created a new app context
    shift
    setup_curr_app_ctx "$@"
    ;;
  "stop") #H: stops the app associated with the the given app context
    [ -n "$HH" ] && exit 0
    if [ -n "$DESIGNATED_VM" ]; then
      multipass stop "$DESIGNATED_VM"
    else
      _log_e 0 "This command only works with managed VMs"
    fi
    ;;
  "start") #H: starts the app associated with the the given app context
    [ -n "$HH" ] && exit 0
    if [ -n "$DESIGNATED_VM" ]; then
      multipass start "$DESIGNATED_VM"
    else
      _log_e 0 "This command only works with managed VMs"
    fi
    ;;
  "delete") #H: delete the given app context
    args_or_ask ${HH:+"$HH"} -n -F "AUTO_YES" "--yes///Assumes yes for all yes-no questions" "$@"
    args_or_ask ${HH:+"$HH"} -F USE_CURRENT_DIR "-l///Uses the local dir as based app dir" "$@"
    [ -n "$HH" ] && exit 0
    shift
    delete_app_ctx "$@"
    ;;
  "list") #H: prints a list of the available app contexts
    args_or_ask ${HH:+"$HH"} -F USE_CURRENT_DIR "-l///Uses the local dir as based app dir" "$@"
    [ -n "$HH" ] && exit 0
    shift
    list_app_ctx "$@"
    ;;
  "login") #H: logins to an application context using a token
    shift
    login_to_app_ctx "$@"
    ;;
  "list-kube-contexts")  #H: prints a list of available contexts from the current kubeconfig
    shift
    list_kube_contexts "$@"
    ;;
  "link-kube-context")  #H: links the current application context to a kube context
    shift
    link_kube_context "$1"
    ;;
  "images") #H: print the images running in the current EntandoApp
    print_images "$@"
    ;;
  "configmap") #H: prints the configmap used to deploy the current EntandoApp
    print_configmap "$@"
    ;;
  "status") #H: prints status information about the current EntandoApp
    local WATCH
    determine_namespace ENTANDO_NAMESPACE "$@"
    args_or_ask ${HH:+"$HH"} -n -p ENTANDO_APPNAME "--appname/ext_ic_id//%sp the application name" "$@"
    args_or_ask ${HH:+"$HH"} -n -F WATCH "--watch///" "$@"

    [ -n "$HH" ] && exit 0

    if $WATCH; then
      ent app-info watch "$ENTANDO_NAMESPACE" "$ENTANDO_APPNAME"
    else
      ent app-info "$ENTANDO_NAMESPACE" "$ENTANDO_APPNAME"
    fi
    ;;
  "")
    args_or_ask ${HH:+"$HH"} -F USE_CURRENT_DIR "-l///Uses the local dir as based app dir" "$@"
    [ -n "$HH" ] && exit 0
    print_current_app_context_info
    _log_i 2 "The available application contexts are:"
    list_app_ctx "$@"
    ;;
  *)
    [ -n "$HH" ] && exit 0
    FATAL "Unknown command \"$CMD\""
    ;;
  esac
}

print_configmap() {
  [ -n "$HH" ] && exit 0
  _kubectl ${NAMESPACE:+-n "$NAMESPACE"} get configmap "entando-docker-image-info" -o yaml |
    perl -p0e 's/.*\n(data:.*)/\1/msg' | perl -p0e 's/\n[^ ].*//msg'
}

print_images() {
  local FILTER="$ENTANDO_IMAGES_FILTER"
  args_or_ask ${HH:+"$HH"} -n -f '--all/// prints all the images' "$@" && {
    FILTER=".*"
  }

  [ -n "$HH" ] && exit 0
  # shellcheck disable=SC2021 disable=SC2155
  local RES=$(
    _kubectl ${NAMESPACE:+-n "$NAMESPACE"} get pods -o jsonpath="{..image}" |
      \tr -s '[[:space:]]' '\n' | \sort -u |
      \grep "$FILTER"
  )
  [ -z "$RES" ] && FATAL "Unable fetch the images list"

  echo "$RES"
  echo ""
  if $OS_WIN; then
    echo "$RES" | sha256sum
  else
    echo "$RES" | shasum -a 256
  fi
}

setup_curr_app_ctx() {
  HH="$(parse_help_option "$@")"
  args_or_ask ${HH:+"$HH"} ENTANDO_APPNAME "--appname/ext_ic_id/$APP_CTX/%sp EntandoApp name" "$@" && {
    save_cfg_value ENTANDO_APPNAME "$ENTANDO_APPNAME"
  }
  args_or_ask ${HH:+"$HH"} ENTANDO_NAMESPACE "--namespace/ext_ic_id/$APP_CTX/%sp default namespace" "$@" && {
    save_cfg_value ENTANDO_NAMESPACE "$ENTANDO_NAMESPACE"
  }
  [ -n "$HH" ] && exit 0
}

use_app_ctx() {
  # shellcheck disable=SC2034
  local application_context
  local apps_base_dir

  if $USE_CURRENT_DIR; then
    apps_base_dir="$ENTANDO_CALLER_PWD/.ent/apps"
  else
    apps_base_dir="$ENTANDO_HOME/apps"
  fi

  $USE_NO_APPCTX && application_context="--none"
  args_or_ask ${HH:+"$HH"} -a -p -n -- "application_context" '1///%sp application context (or --none)' "$@"

  ENTANDO_CURRENT_APP_CTX=""
  # shellcheck disable=SC2034
  ENTANDO_CURRENT_APP_CTX_HOME=""

  if $USE_NO_APPCTX; then
    save_cfg_value "ENTANDO_CURRENT_APP_CTX" "" "$ENTANDO_GLOBAL_CFG"
    save_cfg_value "ENTANDO_CURRENT_APP_CTX_HOME" "" "$ENTANDO_GLOBAL_CFG"
    activate_designated_workdir
    return 0
  else
    (
      # shellcheck disable=SC2030
      local tmp_app_ctx
      if [ "$application_context" = "" ]; then
        __cd "$apps_base_dir"
        # shellcheck disable=SC2035
        map-from-stdin application_context $'\n\r' < <(ls -d * 2>/dev/null)
        args_or_ask_from_list application_context -m -a ${HH:+"$HH"} tmp_app_ctx 1 "any" \
          "application context" "Select the application context" "$@"
      else
        tmp_app_ctx="$application_context"
      fi

      local app_dir="$apps_base_dir/$tmp_app_ctx"

      if [ ! -d "$app_dir" ]; then
        _log_w 0 "Application context \"$tmp_app_ctx\" not found"
        $AUTO_NO && EXIT_UE "Auto Interrupted due to auto-no"
        $AUTO_YES || ask "Should I create it?" || EXIT_UE "User interrupted"
        new_app_ctx "$tmp_app_ctx"
      fi

      save_cfg_value "ENTANDO_CURRENT_APP_CTX" "${tmp_app_ctx}" "$ENTANDO_GLOBAL_CFG"
      save_cfg_value "ENTANDO_CURRENT_APP_CTX_HOME" "${app_dir}" "$ENTANDO_GLOBAL_CFG"
      true
    ) || return $?

    reload_cfg "$ENTANDO_GLOBAL_CFG"
    set_curr_app_ctx "$ENTANDO_CURRENT_APP_CTX" "$ENTANDO_CURRENT_APP_CTX_HOME"
    activate_designated_workdir

    ${APP_CTX_NEVER_USED:-false} && {
      save_cfg_value APP_CTX_NEVER_USED ""
      print_first_use_readme
    }
  fi
}

parse_basic_app_ctx_args() {
  local from="$1"
  shift
  args_or_ask ${HH:+"$HH"} -a ENTANDO_APPNAME "$((from + 0))/ext_ic_id/$APP_CTX/%sp EntandoApp name" "$@"
  args_or_ask ${HH:+"$HH"} -a ENTANDO_NAMESPACE "$((from + 1))/ext_ic_id/$APP_CTX/%sp default namespace" "$@"
}

new_app_ctx() {
  HH="$(parse_help_option "$@")"
  args_or_ask ${HH:+"$HH"} -a APP_CTX "1/ext_ic_id//%sp application context name" "$@"
  args_or_ask ${HH:+"$HH"} -n -F AUTO_USE \
    "--auto-use//true/%sp if true (default) automatically switches to the new application context" "$@"
  args_or_ask ${HH:+"$HH"} -F USE_CURRENT_DIR "-l///%sp uses the local dir as based app dir" "$@"
  parse_basic_app_ctx_args 2 "$@"
  [ -n "$HH" ] && exit 0
  # ~~~~~~~~~~~~~~

  local app_dir
  if $USE_CURRENT_DIR; then
    app_dir="$ENTANDO_CALLER_PWD/.ent/apps/$APP_CTX"
  else
    app_dir="$ENTANDO_HOME/apps/$APP_CTX"
  fi

  [ -d "${app_dir}" ] && FATAL "Application context \"$APP_CTX\" already exists under dir: \"$app_dir\""
  mkdir -p "${app_dir}/w"
  chmod 600 -R "$ENTANDO_ENT_HOME/w"
  chmod 700 "$ENTANDO_ENT_HOME/w"
  _log_i 0 "Application context \"$APP_CTX\" created"

  local cfg_file="$app_dir/w/.cfg"
  save_cfg_value THIS_APP_CTX "$APP_CTX" "$cfg_file"
  save_cfg_value ENTANDO_APPNAME "$ENTANDO_APPNAME" "$cfg_file"
  save_cfg_value ENTANDO_NAMESPACE "$ENTANDO_NAMESPACE" "$cfg_file"

  if $AUTO_USE; then
    set_curr_app_ctx "$APP_CTX" "$app_dir"
    _log_i 0 "Application context \"$APP_CTX\" activated"
    activate_designated_workdir
    print_first_use_readme
  else
    save_cfg_value APP_CTX_NEVER_USED "true" "$cfg_file"
  fi
}

print_first_use_readme() {
  {
    echo ""
    print_hr
    MSG="README PLEASE:"
    MSG+=$'\n'
    MSG+=$'\n'"The kubectl \"mode\" is set to automatic, which means that I'll try to adapt to your system."
    MSG+=$'\n'"However, should that not be enough, you have these options:"
    ((i++))
    MSG+=$'\n'"~"
    MSG+=$'\n'"$i) LOGIN TO A K8S API ENDPOINT:"
    MSG+=$'\n'"   ent app login {url} --token={token} [--kubectl-cmd={command}]"
    ((i++))
    MSG+=$'\n'"~"
    MSG+=$'\n'"$i) SELECT A CONTEXT TO USE:"
    MSG+=$'\n'"   ent app list-contexts"
    MSG+=$'\n'"   ent app set-context {context-name}"
    ((i++))
    MSG+=$'\n'"~"
    MSG+=$'\n'"$i) ATTACH TO A MANAGED VM:"
    MSG+=$'\n'"   ent attach-vm {vm-name}"
    ((i++))
    MSG+=$'\n'"~"
    MSG+=$'\n'"$i) PROVIDE A CUSTOM COMMAND:"
    MSG+=$'\n'"   ent set-kubectl-cmd {command} [--kubeconfig={config}]"
    echo "$MSG"
    print_hr
    echo ""
  } 1>&2
}

delete_app_ctx() {
  # shellcheck disable=SC2034
  local application_context
  local apps_base_dir
  if $USE_CURRENT_DIR; then
    apps_base_dir="$ENTANDO_CALLER_PWD/.ent/apps"
  else
    apps_base_dir="$ENTANDO_HOME/apps"
  fi

  local APP_CTX
  __cd "$apps_base_dir"
  # shellcheck disable=SC2035
  map-from-stdin "application_context" $'\n\r' < <(ls -d * 2>/dev/null)
  args_or_ask_from_list "application_context" -m -a ${HH:+"$HH"} APP_CTX 1 "any" \
    "application context" "Select the application context" "$@"
  [ ! -d "$APP_CTX" ] && FATAL "Application not found"
  [ ! -d "$APP_CTX/w" ] && FATAL "Invalid application context dir"

  (
    _log_w 0 "Application context \"$APP_CTX\" found"
    $AUTO_YES || ask "Should I really delete it?" || EXIT_UE "User interrupted"
    ##########
    # shellcheck disable=SC2034
    # shellcheck disable=SC2030
    (
      ENTANDO_CURRENT_APP_CTX="$APP_CTX"
      ENTANDO_CURRENT_APP_CTX_HOME="$apps_base_dir/$ENTANDO_CURRENT_APP_CTX"
      activate_application_workdir
      reload_cfg

      if [ -n "$DESIGNATED_VM" ]; then
        _log_w 0 "This application context is associated with a managed VM"
        if $AUTO_YES || ask "Should I remove the VM too?"; then
          multipass delete "$DESIGNATED_VM"
          _log_i 0 "VM deleted, to completely remove it run \"multipass purge\""
        fi
      fi
    )
    ##########
    rm -rf "$APP_CTX"
    _log_i 0 "Application context \"$APP_CTX\" deleted"

    save_cfg_value "ENTANDO_CURRENT_APP_CTX" "" "$ENTANDO_GLOBAL_CFG"
    save_cfg_value "ENTANDO_CURRENT_APP_CTX_HOME" "" "$ENTANDO_GLOBAL_CFG"
    true
  ) && {
    reload_cfg "$ENTANDO_GLOBAL_CFG"
    if [ "$APP_CTX" = "$THIS_APP_CTX" ]; then
      THIS_APP_CTX=""
      save_cfg_value "ENTANDO_CURRENT_APP_CTX" "" "$ENTANDO_GLOBAL_CFG"
      save_cfg_value "ENTANDO_CURRENT_APP_CTX_HOME" "" "$ENTANDO_GLOBAL_CFG"
    fi
    print_current_app_context_info
  }
}

list_app_ctx() {
  # shellcheck disable=SC2034
  local application_context
  if $USE_CURRENT_DIR; then
    apps_base_dir="$ENTANDO_CALLER_PWD/.ent/apps"
  else
    apps_base_dir="$ENTANDO_HOME/apps"
  fi

  (
    __cd "$apps_base_dir"
    # shellcheck disable=SC2035
    stdin_to_arr $'\n\r' application_context < <(ls -d * 2>/dev/null)

    for file in "${application_context[@]}"; do
      echo "$file"
    done
  )
}

login_to_app_ctx() {
  local CACHED=false
  args_or_ask -n ${HH:+"$HH"} -F -- "CACHED" "--cached///%sp use cached credential" "$@"
  if ! $CACHED; then
    args_or_ask ${HH:+"$HH"} -a -p -- "APP_LOGIN_URL" '1///%sp URL' "$@"
    args_or_ask ${HH:+"$HH"} -- "APP_LOGIN_TOKEN" "--token///%sp authentication token" "$@"
    args_or_ask -n ${HH:+"$HH"} -- "ENT_KUBECTL_CMD" "--kubectl-cmd///%sp command to use instead of kubectl" "$@"
    [[ -n "$HH" ]] && exit

    reset_kubectl_mode
    save_cfg_value "APP_LOGIN_URL" "$APP_LOGIN_URL"
    save_cfg_value "APP_LOGIN_TOKEN" "$APP_LOGIN_TOKEN"
    save_cfg_value "ENT_KUBECTL_CMD" "$ENT_KUBECTL_CMD"
    setup_kubectl
    _kubectl login "$APP_LOGIN_URL" --token="$APP_LOGIN_TOKEN"
  else
    [[ -n "$HH" && -z "$CMD" ]] && exit
    [[ -z "$APP_LOGIN_URL" || -z "$APP_LOGIN_TOKEN" ]] && FATAL "Credential cache missing or incomplete"
    _kubectl login "$APP_LOGIN_URL" --token="$APP_LOGIN_TOKEN"
  fi
}

select_kube_context() {
  local res_var="$1"; shift
  local kube_context="$1"; shift
  local LST
  stdin_to_arr $'\n\r' LST < <(list_kube_contexts "$kube_context")
  
  if [ "${#LST[@]}" -le 0 ]; then
   [ -n "$kube_context" ] && FATAL "No kube context was found with the provided data"
   FATAL "No kube context was found"
  fi
  
  select_one -s -a "KUBECTX" "${LST[@]}"
  # shellcheck disable=SC2154
  _set_var "$res_var" "$select_one_res_alt" 
}

link_kube_context() {
  local kube_context use_def
  args_or_ask ${HH:+"$HH"} -F -n -- use_def '--default///selects the default kube-context' "$@"  

  if $use_def; then
    args_or_ask -n -a -- kube_context '1///' "$@" && {
      FATAL "It's not allowed to provide \"--default\" and an explicit kube context simultaneously"
    }
    [ -n "$HH" ] && exit 0
    DESIGNATED_KUBE_CTX=""
    save_cfg_value "DESIGNATED_KUBE_CTX" "$DESIGNATED_KUBE_CTX"
  else
    args_or_ask ${HH:+"$HH"} -n -a -- kube_context '1///%spkubernetes context pattern (or --default)' "$@"
    [ -n "$HH" ] && exit 0
    local RES
    select_kube_context RES "$kube_context"
    [ -n "$HH" ] && exit 0
    DESIGNATED_KUBE_CTX="$RES"
    save_cfg_value "DESIGNATED_KUBE_CTX" "$DESIGNATED_KUBE_CTX"   
  fi
  
  exit
}

app_ctx_auto_select_kube_context() {
  :;
}

#app_ctx_auto_login() {
#  if ! $NO_AUTO_LOGIN && login_supported && [[ -n "$APP_LOGIN_URL" && -n "$APP_LOGIN_TOKEN" ]]; then
#    _log_i 0 "Autologin to \"$APP_LOGIN_URL\""
#    _kubectl login "$APP_LOGIN_URL" --token="$APP_LOGIN_TOKEN" || {
#      _log_w 0 "AutoLogin failed, clearing the credentials cache"
#      APP_LOGIN_TOKEN=""
#      save_cfg_value "APP_LOGIN_TOKEN" ""
#    }
#  fi
#}

app_ctx_auto_attach() {
  # shellcheck disable=SC2031
  if [ -n "$DESIGNATED_VM" ]; then
    ent attach-vm "$DESIGNATED_VM"
  fi
}

login_supported() {
  if [ "$ENT_KUBECTL_CMD" = "oc" ] && "${ENABLE_AUTOLOGIN:-true}" != "false"; then
    return 0
  else
    if ${ENABLE_AUTOLOGIN:-false}; then
      return 0
    else
      return 1
    fi
  fi
}

ENTANDO_IMAGES_FILTER=""
ENTANDO_IMAGES_FILTER+="entando-component-manager\|"
ENTANDO_IMAGES_FILTER+="entando-de-app-wildfly\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-app-controller\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-app-plugin-link-controller\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-cluster-infrastructure-controller\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-composite-app-controller\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-controller-coordinator\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-dbjob\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-keycloak-controller\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-plugin-controller\|"
ENTANDO_IMAGES_FILTER+="entando-k8s-service\|"
ENTANDO_IMAGES_FILTER+="entando-keycloak\|"
ENTANDO_IMAGES_FILTER+="entando-plugin-sidecar"

RUN "$@"
