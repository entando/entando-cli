#!/bin/bash

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
cd "$DIR/.." || {
  echo "Internal error: unable to find the script source dir" 1>&2
  exit
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
RUN() {
  require_develop_checked

  while true; do
    cmd="$1"
    shift
    case "$cmd" in
      "init") #H: initializes a project dir
        print_entando_banner
        init_project
        ;;
      "fe-build") #H: builds and package the frontend
        print_entando_banner
        fe_build "$@"
        ;;
      "be-build") #H: builds and package the backend
        print_entando_banner
        be_build "$@"
        ;;
      "be-info") #H: print information about the backend
        be_info "$@"
        ;;
      "gen") #H: generates the project contents
        print_entando_banner
        generate_project "$@"
        ;;
      "init-pub") #H: initializes the publication system
        require_initialized_dir
        init_pub "$@"
        ;;
      "publish-version") #H: bumps a new version given the VERSION_NUMBER
        require_initialized_dir
        publish_version "$@"
        ;;
      "be-push") #H: push the be to the repo
        require_initialized_dir
        be_push "$@"
        ;;
      "test-run") #H: bumps a new version given the VERSION_NUMBER

        ;;
      *)
        H
        break
        ;;
    esac
    index_of_arg "--AND" "$@"
    if [ $? -eq 255 ]; then shift $#; else shift $?; fi
    [ -z "$1" ] && break
  done
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fe_build() {
  require_ent_project_dir
  activate_designated_node
  ./prepareMicrofrontends.sh
}

# shellcheck disable=SC2155
get_be_info() {
  local IMAGE_FQNAME_expr="$(grep "<to>" pom.xml -A 5 | grep "<image>" | head -n 1 | sed 's/<image>\([^<]*\).*/\1/')"
  IMAGE_FQNAME="$(
    ./mvnw -q --non-recursive exec:exec \
      -Dexec.executable="echo" \
      -Dexec.args="'$IMAGE_FQNAME_expr'"
  )"
  [ -z "$IMAGE_FQNAME" ] && {
    _log_w 0 "Unable to determine the image name"
    set_or_ask "IMAGE_FQNAME" "" "Please provide the full image name (org/name:tag)"
  }
  IMAGE_FQNAME_ORG="$(echo "$IMAGE_FQNAME" | awk '{split($0,a,"/"); print a[1]}')"
  local tmp="$(echo "$IMAGE_FQNAME" | awk '{split($0,a,"/"); print a[2]}')"
  IMAGE_FQNAME_NAME="$(echo "$tmp" | awk '{split($0,a,":"); print a[1]}')"
  IMAGE_FQNAME_TAG="$(echo "$tmp" | awk '{split($0,a,":"); print a[2]}')"
}

be_info() {
  get_be_info
  _log_i 0 "Docker image info:\n\
  - IMAGE ORG:  \"$IMAGE_FQNAME_ORG\"\n\
  - IMAGE NAME: \"$IMAGE_FQNAME_NAME\"\n\
  - IMAGE TAG:  \"$IMAGE_FQNAME_TAG\"\n"
}

be_build() {
  require_ent_project_dir
  activate_designated_node

  get_be_info

  ./mvnw -Pprod clean package jib:dockerBuild "$@" && {
    echo ""
    _log_i 0 "Built image \"$IMAGE_FQNAME\""
    true
  } || {
    _log_e 0 "Error building image \"$IMAGE_FQNAME\""
  }
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
publish_version() {
  _log_i 0 "Publishing the frontend to git"
  fe_push "$@"
  _log_i 0 "Publishing the backend to the docker registry"
  be_push
}

fe_push() {
  local PPWD="$PWD"
  push_git "$@"
  local R=$?
  __cd "$PPWD"
  return $R
}

be_push() {
  local PPWD="$PWD"
  get_be_info
  push_docker "$IMAGE_FQNAME"
  local R=$?
  __cd "$PPWD"
  return $R
}

push_docker() {
  [ -z "$DOCKER_REGISTRY_URL" ] && _log_d 1 "No docker registry configured, using default"
  docker login "$DOCKER_REGISTRY_URL"
  docker push "$@"
}

push_git() {
  ensure_valid_location_for_git_publication

  [ "$1" == "--force" ] && {
    shift
    FORCE=true
  } || FORCE=false

  set_or_ask "VERSION_NUMBER" "$1" "%sp %var" "" "assert_fdn"
  set_or_ask "VERSION_COMMENT" "$2" "%sp %var" "$VERSION_NUMBER  - $(date -u '+%Y-%m-%dT%H:%M:%S%z')" "assert_nn"

  cd bundle > /dev/null || FATAL "internal error"

  if [ ! "$(git status --porcelain)" ]; then
    ask "No change detected; Should I proceed anyway?" || EXIT_UE "User interrupted"
  else
    git add -A
    git commit -m "$VERSION_COMMENT"
  fi

  git fetch --tags 1> /dev/null

  if git tag | grep -q -F "$VERSION_NUMBER"; then
    if $FORCE; then
      git tag -d "$VERSION_NUMBER" 2> /dev/null 1>&2
    else
      FATAL "Version \"$VERSION_NUMBER\" already exists"
    fi
  fi

  git tag "$VERSION_NUMBER"

  if $FORCE; then
    RES="$(git push --force 2>&1)"
    RV=$?
  else
    RES="$(git push 2>&1)"
    RV=$?
  fi

  if [ $RV -ne 0 ]; then
    if echo "$RES" | head -n 2 | grep -q -F '! [rejected]'; then
      _log_w 1 "Unable to push to the remote repository, reason; REMOTE HISTORY NOT COMPATIBLE"
      _log_w 1 "I'll try to fix it"

      git fetch origin master \
        && git rebase -Xtheirs origin/master

      RES="$(git push 2>&1)"
      RV=$?
    fi
  fi

  if [ $RV -ne 0 ]; then
    _log_e 1 "Unable to push to the remote repository, reason; $RES"
    FATAL "Manual intervention required"
  else
    if echo "$RES" | head -n 2 | grep -q -F 'up-to-date'; then
      _log_w 1 "Nothing was published: The remote repository is already up to date"
    else
      _log_i 1 "Version $VERSION_NUMBER published"
    fi
  fi

  git push --tags --force 2> /dev/null
  RV=$?
  if [ $RV -ne 0 ]; then
    _log_e 1 "Error pushing the version tag"
  fi
}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_project() {
  _log_i 1 "Preparing.."
  ent-init-project-dir && {
    _log_i 1 "Project initialized."
  }
}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
generate_project() {
  DEF=""
  snake_to_camel DEF "$(basename "$PWD")"

  assert_dn "TEMPLATE_ID" "$1" || FATAL "Please provide a valid template id as first parameter"
  set_or_ask "TEMPLATE_ID" "$1" "Please provide the template id" "base" "assert_dn" "silent"
  shift

  JDLT_FILE="$ENT_HOME/res/$TEMPLATE_ID.jdlt"
  cp "$JDLT_FILE" "prj-generation.jdl~"

  for V in $(# <= don't use read here
    pre_parse_jdlt "$JDLT_FILE"
  ); do
    V="$V/"
    val_name="$(echo "$V" | cut -d'/' -f 1)"
    val_type="$(echo "$V" | cut -d'/' -f 2)"
    val_def="$(echo "$V" | cut -d'/' -f 3)"
    val_msg="$(echo "$V" | cut -d'/' -f 4)"

    index_of_arg -p "${val_name}=" "$@"
    found_at="$?"

    # user provided value
    if [ $found_at -ne 255 ]; then
      val_user="$(echo "${!found_at}" | cut -d'=' -f 2)"
    else
      val_user=""
    fi

    # prompt message processing
    if [ -z "$val_msg" ]; then
      val_msg="Please provide the value for \"$val_name\""
    fi

    # type processing
    if [ -n "$val_type" ]; then
      assertion="assert_$val_type"

      if [ "$(LC_ALL=C type -t "$assertion")" != "function" ]; then
        echo "undefined type \"$val_type\", falling back to \"strict_id\"" 1>&2
        val_type="strict_id"
        assertion="assert_$val_type"
      fi
    else
      assertion=""
    fi

    # ask
    set_or_ask "TMPVAR" "$val_user" "$val_msg" "$val_def" "$assertion"

    # apply
    sed -r --in-place='' 's/\{\{app.serverPort[^}]*\}\}/'"$TMPVAR"'/' prj-generation.jdl~
  done

  _log_i 1 "Configuring.."

  mv "prj-generation.jdl~" "prj-generation.jdl"

  _log_i 1 "Generating the project.."

  _ent-jhipster -blueprint entando import-jdl ./prj-generation.jdl || FATAL "Generation failed"

  #  mkdir bundle
  #  echo -e "\n##############" >> .gitignore
  #  echo bundle >> .gitignore

  generate_ent_project_file
  save_cfg_value "PRJ_NAME" "$PRJ_NAME" "$C_ENT_PRJ_FILE"

  echo ""
  ask "Do you want to commit everything in a new local git repository?" && {
    init_project__commit_all "publication to the frontend repository"
  }

  _log_i 1 "Done."
}

# shellcheck disable=SC2155
init_project__commit_all() {
  local desc="$1"
  local prj_user_name="$(git config --global user.name)"
  local prj_user_email="$(git config --global user.email)"
  local user_global=false

  if [ -n "$prj_user_name" ] && [ -n "$prj_user_email" ]; then
    if ask "Do you want to use you global git user?"; then
      user_global=true
    fi
  fi

  if $user_global; then
    git init
  else
    set_or_ask "FE_PUB_USER_NAME" "" "Please provide the user name for the $desc" "$prj_user_name" "assert_ext_ic_id"
    set_or_ask "FE_PUB_USER_EMAIL" "" "Please provide the user email for the $desc" "$prj_user_email" "assert_email"
    git init
    git config user.name "$FE_PUB_USER_NAME"
    git config user.email "$FE_PUB_USER_EMAIL"
  fi

  _log_i 1 "Committing the generated files.."
  git add -A && git commit -m "First generation commit"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_pub() {
  mkdir -p bundle
  ensure_valid_location_for_git_publication

  PUB_USER_NAME="$(git config user.name 2> /dev/null)"
  PUB_USER_EMAIL="$(git config user.email 2> /dev/null)"

  read_missing_pub_info_from_project_sources_git

  set_or_ask "URL_OF_ORIGIN" "$1" "Please provide the URL of the publication repository" "" "assert_url"
  set_or_ask "PUB_USER_NAME" "$2" "%sp Git %var" "$PUB_USER_NAME" "assert_ext_ic_id"
  set_or_ask "PUB_USER_EMAIL" "$3" "%sp Git %var" "$PUB_USER_EMAIL" "assert_email"

  initialize_publication_git_repository
  ensure_valid_location_for_git_publication :initialized

  _log_i 1 "bundle publication repository initialized"
}

initialize_publication_git_repository() {
  cd bundle > /dev/null || FATAL "internal error"

  # Base git init, if required
  [ ! -f .git ] && {
    git init
  }

  # Set origin, if required
  ORIG="$(git remote get-url origin 2> /dev/null)"
  [ -n "$ORIG" ] && {
    ask "An origin is already present ($ORIG) do you want ot overwrite it?" || EXIT_UE "User abort"
    git remote remove origin
  }
  git remote add origin "$URL_OF_ORIGIN"

  # User info
  git config user.name "$PUB_USER_NAME"
  git config user.email "$PUB_USER_EMAIL"

  cd - > /dev/null || FATAL "internal error"

  # Project: gitignore
  grep -sq "^bundle/$" .gitignore || {
    echo -e "\n####\nbundle/" >> .gitignore
    _log_d 1 "bundle project .gitignore updated"
  }
}

require_ent_project_dir() {
  [ ! -f "$C_ENT_PRJ_FILE" ] \
    && FATAL "The current dir (\"$PWD\") doesn't seem to be a valid bundle project (no project file)"
  [ ! -f "./bundle/$C_BUNDLE_DESCRIPTOR_FILE_NAME" ] \
    && FATAL "The current dir (\"$PWD\") doesn't seem to be a valid bundle project (not bundle dir)"
}

ensure_valid_location_for_git_publication() {
  # valid path
  if [ ! -f "$C_ENT_PRJ_FILE" ]; then
    if [ -f "./bundle/$C_BUNDLE_DESCRIPTOR_FILE_NAME" ]; then
      generate_ent_project_file
    else
      FATAL "The current dir (\"$PWD\") doesn't seem to be a valid bundle project"
    fi
  fi

  if [ "$1" = ":initialized" ]; then
    cd bundle || FATAL "internal error"

    # git initialized
    [ -d ".git" ] || FATAL "Publication repository is not initialized"

    ORIG=$(git remote get-url origin 2> /dev/null)
    [ -z "$ORIG" ] && FATAL "Repo not initialized (run \"${0##*/} init ...\")"

    # git user data set
    [ -z "$(git config user.name 2> /dev/null)" ] && FATAL 'Publication user name is not set'
    [ -z "$(git config user.email 2> /dev/null)" ] && FATAL 'Publication user email is not set'

    # git master branch
    if [ "$(git ls-remote origin master)" ]; then
      _log_w 1 "A remote master has been detected"
      ask "Do you want to import it?" || FATAL "Unable to proceed; manual intervention required"

      if [ "$(git status --porcelain)" ]; then
        local BBN="__AUTOSAVE_$(date -u '+%Y-%m-%dT%H-%M-%S%z')__"
        _log_w 1 "Saving the local changes to the backup branch: \"$BBN\""
        git reset HEAD 2> /dev/null
        git checkout -b "$BBN" \
          && git add -A \
          && git commit -m "$BBN"
      fi

      _log_d 1 "Checking out the remote master"
      git fetch origin master
      git checkout -b master origin/master
    else
      echo "" > .gitignore
      git add -A
      git commit -m "init"
      git checkout -b master
      git push --set-upstream origin master
    fi

    cd - > /dev/null || FATAL "internal error"
  fi

  return 0
}

# If some information is missing tries to read it from the project
read_missing_pub_info_from_project_sources_git() {
  cd .. || FATAL "internal error"

  [ -z "$PUB_USER_NAME" ] && {
    PUB_USER_NAME="$(git config user.name 2> /dev/null)"
    [ -n "$PUB_USER_NAME" ] && _log_d 1 "Assuming user name \"$PUB_USER_NAME\" from the bundle project dir"
  }

  [ -z "$PUB_USER_EMAIL" ] && {
    PUB_USER_EMAIL="$(git config user.email 2> /dev/null)"
    [ -n "$PUB_USER_EMAIL" ] && _log_d 1 "Assuming user email \"$PUB_USER_EMAIL\" from the bundle parent project dir"
  }

  cd - > /dev/null || FATAL "internal error"
}

# ######################################################################################################################
# ######################################################################################################################
# ######################################################################################################################
H() {
  case $1 in
    short)
      echo -e "Helps managing Entando bundle projects | Syntax: (run ${0##*/} [-i|-m] <sub-command>)"
      ;;
    *)
      echo -e "Helps managing Entando bundle projects | Syntax: (run ${0##*/} [-i|-m] <sub-command>)"
      echo "sub-commands:"
      grep '#''H:' "$0" | sed 's/[[:space:]]*\(.*\))[[:space:]]*#''H:\(.*\)/  - \1: \2/'
      ;;
  esac
}

if [ "$1" = "-h" ] || [ "$1" == "" ]; then
  { [ "$2" != "--short" ] && H "full" && exit 0; } || { H "short" && exit 0; }
fi

. s/_base.sh
cd - > /dev/null || FATAL "internal error"

RUN "$@"
